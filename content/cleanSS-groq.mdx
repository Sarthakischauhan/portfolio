import BlogHeader from '../app/components/BlogHeader'
import CodeSnippet from '../app/components/CodeSnippet'
import Image from "next/image"
 
<BlogHeader date='2025-02-26'>
  <h1 className="m-0 p-0">Automate the boring stuff</h1>
  ## Oganize screenshots with python and a dash of AI
  <p className="tag">Tech</p>
  <p className="tag">LLM</p>
  <p className="tag">Teaching</p>
</BlogHeader>

If you are like me and have hundreds of screenshots just lying on your desktop with no information, making everything look messy, then you would love something that can organize those screenshots for you.

I decided to use **groqCloud** and utilize a **llama 3.2 90b vision preview model** to return the category of each screenshot on my desktop and then move them to their respective folders.

## Before and After
Currently, my desktop looked like this:

<div className="relative w-full lg:max-w-[50rem] mx-auto mt-[10px] mb-[10px]
 sm:max-w-[30rem] md:max-w-[50rem]"
 >
    <Image
      src="/pre-cleanss.png"
      alt="Desktop before running our script"
      width={300}
      height={333}
      className="rounded object-cover w-full"
      priority
    />
</div>

After running this script, it will look like this:
<div className="relative w-full lg:max-w-[50rem] mx-auto mt-[10px] mb-[10px]
 sm:max-w-[30rem] md:max-w-[50rem]"
 >
    <Image
      src="/post-cleanss.png"
      alt="Desktop before running our script"
      width={300}
      height={333}
      className="rounded object-cover w-full"
      priority
    />
</div>

## Let's Take a Look at the Code

### Import Required Libraries
We are using the `groq` library, which is OpenAI-compatible and will be used to access our model hosted on `groqcloud`.

<CodeSnippet>
```python
#! /base/bin/python3
import os
import glob
import base64
from dotenv import load_dotenv # type: ignore
from groq import Groq # type: ignore
import json
import shutil
from PIL import Image
from io import BytesIO
from datetime import datetime

load_dotenv()
```
</CodeSnippet>

### Creating a Class for Organization
I will take a classic object-oriented approach and create a class `CleanScreenShots` and define some class variables.

<CodeSnippet>
```python
class CleanScreenShots:
    DESKTOP_PATH = os.path.join(os.path.expanduser("~"), "Desktop")
    ALLOWED_CATEGORIES = ["Meme", "Study", "Documents", "Random", "Images"]
    # Generic code coming soon
```
</CodeSnippet>
### Fetching Screenshots
Our function `get_screenshots()` will fetch all the screenshots stored on the desktop. It searches for file names that contain `Screenshot` in their name.

<CodeSnippet>
```python
def get_screenshots(self):
    patterns = [os.path.join(self.DESKTOP_PATH, f"*Screenshot*.{ext}") for ext in ["png", "jpg", "jpeg"]]
    screenshots = []
    for pattern in patterns:
        screenshots.extend(glob.glob(pattern))
    return screenshots
```
</CodeSnippet>

### Processing Images
- **Check Image Size**: If the image is greater than 2.5MB, compress it to stay within the token limit.
- **Encode to Base64**: Required for sending local image data to `groq`.
- **Generate MIME Type**: Used as a prefix for sending data.

<CodeSnippet>
```python
def compress_resize_image(self, image_path, max_size=2.5 * 1024 * 1024):
    img = Image.open(image_path)
    img.thumbnail((1920, 1080))
    buf = BytesIO()
    ext = os.path.splitext(image_path)[1].lower()
    if ext in [".jpg", ".jpeg"]:
        img.save(buf, format="JPEG", quality=85)
    else:
        img.save(buf, format="PNG", optimize=True)
    return base64.b64encode(buf.getvalue()).decode("utf-8")

def encode_image(self, image_path):
    max_size = 2.5 * 1024 * 1024
    if os.path.getsize(image_path) > max_size:
        return self.compress_resize_image(image_path, max_size)
    else:
        with open(image_path, "rb") as image_file:
            return base64.b64encode(image_file.read()).decode("utf-8")

def get_mime_type(self, image_path):
# Creating prefix for base64 data based on file extension type
    ext = os.path.splitext(image_path)[1].lower()
    if ext == ".png":
        return "image/png"
    elif ext in [".jpg", ".jpeg"]:
        return "image/jpeg"
    else:
        return "application/octet-stream"
```
</CodeSnippet>

### Categorization Prompt
The following prompt will be used to categorize the images:

<CodeSnippet>
```python
prompt = f"""Categorize the following image into one of these categories:
    Meme : Generally images with some satirical text or just funny images.
    Study : Math equations, formulas, experiment results.
    Documents: PDFs or text-based documents with useful information.
    Random: Code snippets, outdated tickets, invitations.
    Images: Images of people that are not memes.

    Always return only a JSON object in the schema:
    {{"category": "value"}}

    The current date is {datetime.today().strftime('%Y-%m-%d')}
"""
```
</CodeSnippet>

### Processing and Moving Images
<CodeSnippet>
```python
def process_all_screenshots(self):
    screenshots = self.get_screenshots()
    assert screenshots, "No screenshots matched, check screenshot names"
    k = 0
    while k < len(screenshots):
        batch = screenshots[k:k+5]
        for image_path in batch:
            print(f"Processing {image_path}...")
            result = json.loads(self.categorize_image(image_path))
            category = result["category"]
            self.save_to_folders(category, image_path)

        if k + 5 < len(screenshots):
            proceed = input("Do you wish to continue? (y/n): ").strip().lower()
            if proceed in ["n", "no"]:
                break
        k += 5
```
</CodeSnippet>

### Running the Script
<CodeSnippet>
```python
if __name__ == "__main__":
    cs = CleanScreenShots()
    cs.process_all_screenshots()
```
</CodeSnippet>

